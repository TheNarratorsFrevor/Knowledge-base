<h2>Let it be</h2>
<p>
Very similar to where bindings are let bindings. Where bindings are a syntactic construct that let you bind to variables at the end of a function and the whole function can see them, including all the guards. Let bindings let you bind to variables anywhere and are expressions themselves, but are very local, so they don't span across guards. Just like any construct in Haskell that is used to bind values to names, let bindings can be used for pattern matching. Let's see them in action! This is how we could define a function that gives us a cylinder's surface area based on its height and radius:
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>cylinder</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">RealFloat</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>cylinder&nbsp;r&nbsp;h<span class="common_operators">&nbsp;=</span>&nbsp;</span></li><li class="alt"><span><span class="common_operators"></span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">let</span><span>&nbsp;sideArea</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">2</span><span class="common_operators">&nbsp;*&nbsp;</span><span>pi</span><span class="common_operators">&nbsp;*&nbsp;</span><span>r</span><span class="common_operators">&nbsp;*&nbsp;</span><span>h&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topArea<span class="common_operators">&nbsp;=&nbsp;</span><span>pi</span><span class="common_operators">&nbsp;*&nbsp;</span><span>r&nbsp;^</span><span class="numbers">2</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">in</span><span>&nbsp;&nbsp;sideArea</span><span class="common_operators">&nbsp;+&nbsp;</span><span class="numbers">2</span><span class="common_operators">&nbsp;*&nbsp;</span><span>topArea&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^2
    in  sideArea + 2 * topArea
</pre>
<img src="http://s3.amazonaws.com/lyah/letitbe.png" alt="let it be" class="right" width="215" height="240">
<p>The form is <span class="fixed">let &lt;bindings&gt; in &lt;expression&gt;</span>. The names that you define in the <i>let</i> part are accessible to the expression after the <i>in</i> part. As you can see, we could have also defined this with a <i>where</i> binding. Notice that the names are also aligned in a single column. So what's the difference between the two? For now it just seems that <i>let</i> puts the bindings first and the expression that uses them later whereas <i>where</i> is the other way around.</p>
<p>The difference is that <i>let</i> bindings are expressions themselves. <i>where</i> bindings are just syntactic constructs. Remember when we did the if statement and it was explained that an if else statement is an expression and you can cram it in almost anywhere?</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="keyword">if</span><span>&nbsp;</span><span class="numbers">5</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span class="numbers">3</span><span>&nbsp;</span><span class="keyword">then</span><span>&nbsp;</span><span class="string">"Woo"</span><span>&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="string">"Boo"</span><span>,&nbsp;</span><span class="keyword">if</span><span>&nbsp;</span><span class="char">'a'</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span class="char">'b'</span><span>&nbsp;</span><span class="keyword">then</span><span>&nbsp;</span><span class="string">"Foo"</span><span>&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="string">"Bar"</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="string">"Woo"</span><span>,&nbsp;</span><span class="string">"Bar"</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="numbers">4</span><span class="common_operators">&nbsp;*&nbsp;</span><span>(</span><span class="keyword">if</span><span>&nbsp;</span><span class="numbers">10</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span class="numbers">5</span><span>&nbsp;</span><span class="keyword">then</span><span>&nbsp;</span><span class="numbers">10</span><span>&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="numbers">0</span><span>)</span><span class="common_operators">&nbsp;+&nbsp;</span><span class="numbers">2</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">42</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; [if 5 &gt; 3 then "Woo" else "Boo", if 'a' &gt; 'b' then "Foo" else "Bar"]
["Woo", "Bar"]
ghci&gt; 4 * (if 10 &gt; 5 then 10 else 0) + 2
42
</pre>
<p>You can also do that with let bindings.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="numbers">4</span><span class="common_operators">&nbsp;*&nbsp;</span><span>(</span><span class="keyword">let</span><span>&nbsp;a</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">9</span><span>&nbsp;</span><span class="keyword">in</span><span>&nbsp;a</span><span class="common_operators">&nbsp;+&nbsp;</span><span class="numbers">1</span><span>)</span><span class="common_operators">&nbsp;+&nbsp;</span><span class="numbers">2</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">42</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; 4 * (let a = 9 in a + 1) + 2
42
</pre>
<p>They can also be used to introduce functions in a local scope:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="keyword">let</span><span>&nbsp;square&nbsp;x</span><span class="common_operators">&nbsp;=&nbsp;</span><span>x</span><span class="common_operators">&nbsp;*&nbsp;</span><span>x&nbsp;</span><span class="keyword">in</span><span>&nbsp;(square&nbsp;</span><span class="numbers">5</span><span>,&nbsp;square&nbsp;</span><span class="numbers">3</span><span>,&nbsp;square&nbsp;</span><span class="numbers">2</span><span>)]&nbsp;&nbsp;</span></span></li><li class=""><span>[(<span class="numbers">25</span><span>,</span><span class="numbers">9</span><span>,</span><span class="numbers">4</span><span>)]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; [let square x = x * x in (square 5, square 3, square 2)]
[(25,9,4)]
</pre>
<p>If we want to bind to several variables inline, we obviously can't align them at columns. That's why we can separate them with semicolons.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;(</span><span class="keyword">let</span><span>&nbsp;a</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">100</span><span>;&nbsp;b</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">200</span><span>;&nbsp;c</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">300</span><span>&nbsp;</span><span class="keyword">in</span><span>&nbsp;a*b*c,&nbsp;</span><span class="keyword">let</span><span>&nbsp;foo=</span><span class="string">"Hey&nbsp;"</span><span>;&nbsp;bar</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"there!"</span><span>&nbsp;</span><span class="keyword">in</span><span>&nbsp;foo</span><span class="common_operators">&nbsp;++&nbsp;</span><span>bar)&nbsp;&nbsp;</span></span></li><li class=""><span>(<span class="numbers">6000000</span><span>,</span><span class="string">"Hey&nbsp;there!"</span><span>)&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
(6000000,"Hey there!")
</pre>
<p>You don't have to put a semicolon after the last binding but you can if you want. Like we said before, you can pattern match with <i>let</i> bindings. They're very useful for quickly dismantling a tuple into components and binding them to names and such.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;(</span><span class="keyword">let</span><span>&nbsp;(a,b,c)</span><span class="common_operators">&nbsp;=&nbsp;</span><span>(</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>)&nbsp;</span><span class="keyword">in</span><span>&nbsp;a+b+c)</span><span class="common_operators">&nbsp;*&nbsp;</span><span class="numbers">100</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">600</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; (let (a,b,c) = (1,2,3) in a+b+c) * 100
600
</pre>
<p>You can also put <i>let</i> bindings inside list comprehensions. Let's rewrite our previous example of calculating lists of weight-height pairs to use a <i>let</i> inside a list comprehension instead of defining an auxiliary function with a <i>where</i>.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>calcBmis</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">RealFloat</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>[(a,&nbsp;a)]</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>[a]&nbsp;&nbsp;</span></span></li><li class=""><span>calcBmis&nbsp;xs<span class="common_operators">&nbsp;=&nbsp;</span><span>[bmi</span><span class="common_operators">&nbsp;|&nbsp;</span><span>(w,&nbsp;h)</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>xs,&nbsp;</span><span class="keyword">let</span><span>&nbsp;bmi</span><span class="common_operators">&nbsp;=&nbsp;</span><span>w</span><span class="common_operators">&nbsp;/&nbsp;</span><span>h</span><span class="common_operators">&nbsp;^&nbsp;</span><span class="numbers">2</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]
calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w / h ^ 2]
</pre>
<p>We include a <i>let</i> inside a list comprehension much like we would a predicate, only it doesn't filter the list, it only binds to names. The names defined in a <i>let</i> inside a list comprehension are visible to the output function (the part before the <span class="fixed">|</span>) and all predicates and sections that come after of the binding. So we could make our function return only the BMIs of fat people:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>calcBmis</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">RealFloat</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>[(a,&nbsp;a)]</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>[a]&nbsp;&nbsp;</span></span></li><li class=""><span>calcBmis&nbsp;xs<span class="common_operators">&nbsp;=&nbsp;</span><span>[bmi</span><span class="common_operators">&nbsp;|&nbsp;</span><span>(w,&nbsp;h)</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>xs,&nbsp;</span><span class="keyword">let</span><span>&nbsp;bmi</span><span class="common_operators">&nbsp;=&nbsp;</span><span>w</span><span class="common_operators">&nbsp;/&nbsp;</span><span>h</span><span class="common_operators">&nbsp;^&nbsp;</span><span class="numbers">2</span><span>,&nbsp;bmi</span><span class="common_operators">&nbsp;&gt;=&nbsp;</span><span class="numbers">25.0</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]
calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w / h ^ 2, bmi &gt;= 25.0]
</pre>
<p>We can't use the <span class="fixed">bmi</span> name in the <span class="fixed">(w, h) &lt;- xs</span> part because it's defined prior to the <i>let</i> binding.</p> 
<p>We omitted the <i>in</i> part of the <i>let</i> binding when we used them in list comprehensions because the visibility of the names is already predefined there. However, we could use a <i>let in</i> binding in a predicate and the names defined would only be visible to that predicate. The <i>in</i> part can also be omitted when defining functions and constants directly in GHCi. If we do that, then the names will be visible throughout the entire interactive session.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;zoot&nbsp;x&nbsp;y&nbsp;z</span><span class="common_operators">&nbsp;=&nbsp;</span><span>x</span><span class="common_operators">&nbsp;*&nbsp;</span><span>y</span><span class="common_operators">&nbsp;+&nbsp;</span><span>z&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;zoot&nbsp;</span><span class="numbers">3</span><span>&nbsp;</span><span class="numbers">9</span><span>&nbsp;</span><span class="numbers">2</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="numbers">29</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;boot&nbsp;x&nbsp;y&nbsp;z</span><span class="common_operators">&nbsp;=&nbsp;</span><span>x</span><span class="common_operators">&nbsp;*&nbsp;</span><span>y</span><span class="common_operators">&nbsp;+&nbsp;</span><span>z&nbsp;</span><span class="keyword">in</span><span>&nbsp;boot&nbsp;</span><span class="numbers">3</span><span>&nbsp;</span><span class="numbers">4</span><span>&nbsp;</span><span class="numbers">2</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="numbers">14</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;boot&nbsp;&nbsp;</span></span></li><li class="alt"><span>&lt;interactive&gt;:<span class="numbers">1</span><span>:</span><span class="numbers">0</span><span>:&nbsp;</span><span class="type_constructors">Not</span><span>&nbsp;</span><span class="keyword">in</span><span>&nbsp;scope:&nbsp;`boot'&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; let zoot x y z = x * y + z
ghci&gt; zoot 3 9 2
29
ghci&gt; let boot x y z = x * y + z in boot 3 4 2
14
ghci&gt; boot
&lt;interactive&gt;:1:0: Not in scope: `boot'
</pre>
<p>If <i>let</i> bindings are so cool, why not use them all the time instead of <i>where</i> bindings, you ask? Well, since <i>let</i> bindings are expressions and are fairly local in their scope, they can't be used across guards. Some people prefer <i>where</i> bindings because the names come after the function they're being used in. That way, the function body is closer to its name and type declaration and to some that's more readable.</p>