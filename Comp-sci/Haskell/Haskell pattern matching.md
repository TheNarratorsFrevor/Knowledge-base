<h2>Pattern matching</h2>
<img src="http://s3.amazonaws.com/lyah/pattern.png" alt="four!" class="right" width="162" height="250">
<p>This chapter will cover some of Haskell's cool syntactic constructs and we'll start with pattern matching. Pattern matching consists of specifying patterns to which some data should conform and then checking to see if it does and deconstructing the data according to those patterns.</p>
<p>When defining functions, you can define separate function bodies for different patterns. This leads to really neat code that's simple and readable. You can pattern match on any data type — numbers, characters, lists, tuples, etc. Let's make a really trivial function that checks if the number we supplied to it is a seven or not.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>lucky</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Integral</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">String</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>lucky&nbsp;<span class="numbers">7</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"LUCKY&nbsp;NUMBER&nbsp;SEVEN!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>lucky&nbsp;x<span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Sorry,&nbsp;you're&nbsp;out&nbsp;of&nbsp;luck,&nbsp;pal!"</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">lucky :: (Integral a) =&gt; a -&gt; String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!" </pre>
<p>When you call <span class="fixed">lucky</span>, the patterns will be checked from top to bottom and when it conforms to a pattern, the corresponding function body will be used. The only way a number can conform to the first pattern here is if it is 7. If it's not, it falls through to the second pattern, which matches anything and binds it to <span class="fixed">x</span>. This function could have also been implemented by using an if statement. But what if we wanted a function that says the numbers from 1 to 5 and says <span class="fixed">"Not between 1 and 5"</span> for any other number? Without pattern matching, we'd have to make a pretty convoluted if then else tree. However, with it:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>sayMe</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Integral</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">String</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>sayMe&nbsp;<span class="numbers">1</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"One!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>sayMe&nbsp;<span class="numbers">2</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Two!"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>sayMe&nbsp;<span class="numbers">3</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Three!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>sayMe&nbsp;<span class="numbers">4</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Four!"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>sayMe&nbsp;<span class="numbers">5</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Five!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>sayMe&nbsp;x<span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Not&nbsp;between&nbsp;1&nbsp;and&nbsp;5"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">sayMe :: (Integral a) =&gt; a -&gt; String
sayMe 1 = "One!"
sayMe 2 = "Two!"
sayMe 3 = "Three!"
sayMe 4 = "Four!"
sayMe 5 = "Five!"
sayMe x = "Not between 1 and 5"
</pre>
<p>Note that if we moved the last pattern (the catch-all one) to the top, it would always say <span class="fixed">"Not between 1 and 5"</span>, because it would catch all the numbers and they wouldn't have a chance to fall through and be checked for any other patterns.</p>
<p>Remember the factorial function we implemented previously? We defined the factorial of a number <span class="fixed">n</span> as <span class="fixed">product [1..n]</span>. We can also define a factorial function <i>recursively</i>, the way it is usually defined in mathematics. We start by saying that the factorial of 0 is 1. Then we state that the factorial of any positive integer is that integer multiplied by the factorial of its predecessor. Here's how that looks like translated in Haskell terms.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>factorial</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Integral</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>factorial&nbsp;<span class="numbers">0</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">1</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>factorial&nbsp;n<span class="common_operators">&nbsp;=&nbsp;</span><span>n</span><span class="common_operators">&nbsp;*&nbsp;</span><span>factorial&nbsp;(n</span><span class="common_operators">&nbsp;-&nbsp;</span><span class="numbers">1</span><span>)&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">factorial :: (Integral a) =&gt; a -&gt; a
factorial 0 = 1
factorial n = n * factorial (n - 1)
</pre>
<p>
This is the first time we've defined a function recursively. Recursion is important in Haskell and we'll take a closer look at it later. But in a nutshell, this is what happens if we try to get the factorial of, say, 3. It tries to compute <span class="fixed">3 * factorial 2</span>. The factorial of 2 is <span class="fixed">2 * factorial 1</span>, so for now we have <span class="fixed">3 * (2 * factorial 1)</span>. <span class="fixed">factorial 1</span> is <span class="fixed">1 * factorial 0</span>, so we have <span class="fixed">3 * (2 * (1 * factorial 0))</span>. Now here comes the trick — we've defined the factorial of 0 to be just 1 and because it encounters that pattern before the catch-all one, it just returns 1. So the final result is equivalent to <span class="fixed">3 * (2 * (1 * 1))</span>. Had we written the second pattern on top of the first one, it would catch all numbers, including 0 and our calculation would never terminate. That's why order is important when specifying patterns and it's always best to specify the most specific ones first and then the more general ones later.</p>
<p>
Pattern matching can also fail. If we define a function like this:
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>charName</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span class="type_constructors">Char</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">String</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>charName&nbsp;<span class="char">'a'</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Albert"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>charName&nbsp;<span class="char">'b'</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Broseph"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>charName&nbsp;<span class="char">'c'</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Cecil"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">charName :: Char -&gt; String
charName 'a' = "Albert"
charName 'b' = "Broseph"
charName 'c' = "Cecil"
</pre>
<p>and then try to call it with an input that we didn't expect, this is what happens:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;charName&nbsp;</span><span class="char">'a'</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"Albert"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;charName&nbsp;</span><span class="char">'b'</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"Broseph"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;charName&nbsp;</span><span class="char">'h'</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>"***&nbsp;<span class="type_constructors">Exception</span><span>:&nbsp;tut.hs:(</span><span class="numbers">53</span><span>,</span><span class="numbers">0</span><span>)-(</span><span class="numbers">55</span><span>,</span><span class="numbers">21</span><span>):&nbsp;</span><span class="type_constructors">Non</span><span>-exhaustive&nbsp;patterns&nbsp;</span><span class="keyword">in</span><span>&nbsp;function&nbsp;charName&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; charName 'a'
"Albert"
ghci&gt; charName 'b'
"Broseph"
ghci&gt; charName 'h'
"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName
</pre>
<p>
It complains that we have non-exhaustive patterns, and rightfully so. When making patterns, we should always include a catch-all pattern so that our program doesn't crash if we get some unexpected input.
</p>
<p>Pattern matching can also be used on tuples. What if we wanted to make a function that takes two vectors in a 2D space (that are in the form of pairs) and adds them together? To add together two vectors, we add their x components separately and then their y components separately. Here's how we would have done it if we didn't know about pattern matching:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>addVectors</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Num</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>(a,&nbsp;a)</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>(a,&nbsp;a)</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>(a,&nbsp;a)&nbsp;&nbsp;</span></span></li><li class=""><span>addVectors&nbsp;a&nbsp;b<span class="common_operators">&nbsp;=&nbsp;</span><span>(fst&nbsp;a</span><span class="common_operators">&nbsp;+&nbsp;</span><span>fst&nbsp;b,&nbsp;snd&nbsp;a</span><span class="common_operators">&nbsp;+&nbsp;</span><span>snd&nbsp;b)&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)
addVectors a b = (fst a + fst b, snd a + snd b)
</pre>
<p>Well, that works, but there's a better way to do it. Let's modify the function so that it uses pattern matching.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>addVectors</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Num</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>(a,&nbsp;a)</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>(a,&nbsp;a)</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>(a,&nbsp;a)&nbsp;&nbsp;</span></span></li><li class=""><span>addVectors&nbsp;(x1,&nbsp;y1)&nbsp;(x2,&nbsp;y2)<span class="common_operators">&nbsp;=&nbsp;</span><span>(x1</span><span class="common_operators">&nbsp;+&nbsp;</span><span>x2,&nbsp;y1</span><span class="common_operators">&nbsp;+&nbsp;</span><span>y2)&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
</pre>
<p>There we go! Much better. Note that this is already a catch-all pattern. The type of <span class="fixed">addVectors</span> (in both cases) is <span class="fixed">addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) - &gt; (a, a)</span>, so we are guaranteed to get two pairs as parameters.</p>
<p><span class="fixed">fst</span> and <span class="fixed">snd</span> extract the components of pairs. But what about triples? Well, there are no provided functions that do that but we can make our own.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>first</span><span class="syntax_operators">&nbsp;==&nbsp;</span><span>(a,&nbsp;b,&nbsp;c)</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>first&nbsp;(x,&nbsp;_,&nbsp;_)<span class="common_operators">&nbsp;=&nbsp;</span><span>x&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li class=""><span>second<span class="syntax_operators">&nbsp;==&nbsp;</span><span>(a,&nbsp;b,&nbsp;c)</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>b&nbsp;&nbsp;</span></span></li><li class="alt"><span>second&nbsp;(_,&nbsp;y,&nbsp;_)<span class="common_operators">&nbsp;=&nbsp;</span><span>y&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;</span></li><li class="alt"><span>third<span class="syntax_operators">&nbsp;::&nbsp;</span><span>(a,&nbsp;b,&nbsp;c)</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>c&nbsp;&nbsp;</span></span></li><li class=""><span>third&nbsp;(_,&nbsp;_,&nbsp;z)<span class="common_operators">&nbsp;=&nbsp;</span><span>z&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">first :: (a, b, c) -&gt; a
first (x, _, _) = x

second :: (a, b, c) -&gt; b
second (_, y, _) = y

third :: (a, b, c) -&gt; c
third (_, _, z) = z
</pre>
<p>The <span class="fixed">_</span> means the same thing as it does in list comprehensions. It means that we really don't care what that part is, so we just write a <span class="fixed">_</span>.</p>
<p>Which reminds me, you can also pattern match in list comprehensions. Check this out:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;xs</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[(</span><span class="numbers">1</span><span>,</span><span class="numbers">3</span><span>),&nbsp;(</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>),&nbsp;(</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>),&nbsp;(</span><span class="numbers">5</span><span>,</span><span class="numbers">3</span><span>),&nbsp;(</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>),&nbsp;(</span><span class="numbers">3</span><span>,</span><span class="numbers">1</span><span>)]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;[a+b</span><span class="common_operators">&nbsp;|&nbsp;</span><span>(a,b)</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>xs]&nbsp;&nbsp;</span></span></li><li class="alt"><span>[<span class="numbers">4</span><span>,</span><span class="numbers">7</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">11</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
ghci&gt; [a+b | (a,b) &lt;- xs]
[4,7,6,8,11,4] </pre>
<p>
Should a pattern match fail, it will just move on to the next element.
</p>
<p>Lists themselves can also be used in pattern matching. You can match with the empty list <span class="fixed">[]</span> or any pattern that involves <span class="fixed">:</span> and the empty list. But since <span class="fixed">[1,2,3]</span> is just syntactic sugar for <span class="fixed">1:2:3:[]</span>, you can also use the former pattern. A pattern like <span class="fixed">x:xs</span> will bind the head of the list to <span class="fixed">x</span> and the rest of it to <span class="fixed">xs</span>, even if there's only one element so <span class="fixed">xs</span> ends up being an empty list. </p>
<div class="hintbox"><em>Note</em>: The <span class="fixed">x:xs</span> pattern is used a lot, especially with recursive functions. But patterns that have <span class="fixed">:</span> in them only match against lists of length 1 or more.</div>
<p>If you want to bind, say, the first three elements to variables and the rest of the list to another variable, you can use something like <span class="fixed">x:y:z:zs</span>. It will only match against lists that have three elements or more.</p>
<p>Now that we know how to pattern match against list, let's make our own implementation of the <span class="fixed">head</span> function.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>head'</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>[a]</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>head'&nbsp;[]<span class="common_operators">&nbsp;=&nbsp;</span><span>error&nbsp;</span><span class="string">"Can't&nbsp;call&nbsp;head&nbsp;on&nbsp;an&nbsp;empty&nbsp;list,&nbsp;dummy!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>head'&nbsp;(x:_)<span class="common_operators">&nbsp;=&nbsp;</span><span>x&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">head' :: [a] -&gt; a
head' [] = error "Can't call head on an empty list, dummy!"
head' (x:_) = x
</pre>
<p>Checking if it works:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;head'&nbsp;[</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">4</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;head'&nbsp;</span><span class="string">"Hello"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="char">'H'</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; head' [4,5,6]
4
ghci&gt; head' "Hello"
'H'
</pre>
<p>
Nice! Notice that if you want to bind to several variables (even if one of them is just <span class="fixed">_</span> and doesn't actually bind at all), we have to surround them in parentheses. Also notice the <span class="fixed">error</span> function that we used. It takes a string and generates a runtime error, using that string as information about what kind of error occurred. It causes the program to crash, so it's not good to use it too much. But calling <span class="fixed">head</span> on an empty list doesn't make sense.
</p>
<p>Let's make a trivial function that tells us some of the first elements of the list in (in)convenient English form.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>tell</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Show</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>[a]</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">String</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>tell&nbsp;[]<span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"The&nbsp;list&nbsp;is&nbsp;empty"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>tell&nbsp;(x:[])<span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"The&nbsp;list&nbsp;has&nbsp;one&nbsp;element:&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>show&nbsp;x&nbsp;&nbsp;</span></span></li><li class=""><span>tell&nbsp;(x:y:[])<span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"The&nbsp;list&nbsp;has&nbsp;two&nbsp;elements:&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>show&nbsp;x</span><span class="common_operators">&nbsp;++&nbsp;</span><span class="string">"&nbsp;and&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>show&nbsp;y&nbsp;&nbsp;</span></span></li><li class="alt"><span>tell&nbsp;(x:y:_)<span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"This&nbsp;list&nbsp;is&nbsp;long.&nbsp;The&nbsp;first&nbsp;two&nbsp;elements&nbsp;are:&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>show&nbsp;x</span><span class="common_operators">&nbsp;++&nbsp;</span><span class="string">"&nbsp;and&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>show&nbsp;y&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">tell :: (Show a) =&gt; [a] -&gt; String
tell [] = "The list is empty"
tell (x:[]) = "The list has one element: " ++ show x
tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y
tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
</pre>
<p>This function is safe because it takes care of the empty list, a singleton list, a list with two elements and a list with more than two elements. Note that <span class="fixed">(x:[])</span> and <span class="fixed">(x:y:[])</span> could be rewriten as <span class="fixed">[x]</span> and <span class="fixed">[x,y]</span> (because its syntatic sugar, we don't need the parentheses). We can't rewrite <span class="fixed">(x:y:_)</span> with square brackets because it matches any list of length 2 or more.</p>
<p>We already implemented our own <span class="fixed">length</span> function using list comprehension. Now we'll do it by using pattern matching and a little recursion:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>length'</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Num</span><span>&nbsp;b)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>[a]</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>b&nbsp;&nbsp;</span></span></li><li class=""><span>length'&nbsp;[]<span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">0</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>length'&nbsp;(_:xs)<span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">1</span><span class="common_operators">&nbsp;+&nbsp;</span><span>length'&nbsp;xs&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">length' :: (Num b) =&gt; [a] -&gt; b
length' [] = 0
length' (_:xs) = 1 + length' xs</pre>
<p>This is similar to the factorial function we wrote earlier. First we defined the result of a known input — the empty list. This is also known as the edge condition. Then in the second pattern we take the list apart by splitting it into a head and a tail. We say that the length is equal to 1 plus the length of the tail. We use <span class="fixed">_</span> to match the head because we don't actually care what it is. Also note that we've taken care of all possible patterns of a list. The first pattern matches an empty list and the second one matches anything that isn't an empty list.</p>
<p>Let's see what happens if we call <span class="fixed">length'</span> on <span class="fixed">"ham"</span>. First, it will check if it's an empty list. Because it isn't, it falls through to the second pattern. It matches on the second pattern and there it says that the length is <span class="fixed">1 + length' "am"</span>, because we broke it into a head and a tail and discarded the head. O-kay. The <span class="fixed">length'</span> of <span class="fixed">"am"</span> is, similarly, <span class="fixed">1 + length' "m"</span>. So right now we have <span class="fixed">1 + (1 + length' "m")</span>. <span class="fixed">length' "m"</span> is <span class="fixed">1 + length' ""</span> (could also be written as <span class="fixed">1 + length' []</span>). And we've defined <span class="fixed">length' []</span> to be <span class="fixed">0</span>. So in the end we have <span class="fixed">1 + (1 + (1 + 0))</span>.</p>
<p>Let's implement <span class="fixed">sum</span>. We know that the sum of an empty list is 0. We write that down as a pattern. And we also know that the sum of a list is the head plus the sum of the rest of the list. So if we write that down, we get:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>sum'</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Num</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>[a]</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>sum'&nbsp;[]<span class="common_operators">&nbsp;=&nbsp;</span><span class="numbers">0</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>sum'&nbsp;(x:xs)<span class="common_operators">&nbsp;=&nbsp;</span><span>x</span><span class="common_operators">&nbsp;+&nbsp;</span><span>sum'&nbsp;xs&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:nogutter:nocontrols:hs" style="display: none;">sum' :: (Num a) =&gt; [a] -&gt; a
sum' [] = 0
sum' (x:xs) = x + sum' xs
</pre>
<p>There's also a thing called <i>as patterns</i>. Those are a handy way of breaking something up according to a pattern and binding it to names whilst still keeping a reference to the whole thing. You do that by putting a name and an <span class="fixed">@</span> in front of a pattern. For instance, the pattern <span class="fixed">xs@(x:y:ys)</span>. This pattern will match exactly the same thing as <span class="fixed">x:y:ys</span> but you can easily get the whole list via <span class="fixed">xs</span> instead of repeating yourself by typing out <span class="fixed">x:y:ys</span> in the function body again. Here's a quick and dirty example:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>capital</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span class="type_constructors">String</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">String</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>capital&nbsp;<span class="string">""</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"Empty&nbsp;string,&nbsp;whoops!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>capital&nbsp;all@(x:xs)<span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"The&nbsp;first&nbsp;letter&nbsp;of&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>all</span><span class="common_operators">&nbsp;++&nbsp;</span><span class="string">"&nbsp;is&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>[x]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:nogutter:nocontrols:hs" style="display: none;">capital :: String -&gt; String
capital "" = "Empty string, whoops!"
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
</pre>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;capital&nbsp;</span><span class="string">"Dracula"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"The&nbsp;first&nbsp;letter&nbsp;of&nbsp;Dracula&nbsp;is&nbsp;D"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; capital "Dracula"
"The first letter of Dracula is D"
</pre>
<p>Normally we use as patterns to avoid repeating ourselves when matching against a bigger pattern when we have to use the whole thing again in the function body.</p>
<p>One more thing — you can't use <span class="fixed">++</span> in pattern matches. If you tried to pattern match against <span class="fixed">(xs ++ ys)</span>, what would be in the first and what would be in the second list? It doesn't make much sense. It would make sense to match stuff against <span class="fixed">(xs ++ [x,y,z])</span> or just <span class="fixed">(xs ++ [x])</span>, but because of the nature of lists, you can't do that.</p>