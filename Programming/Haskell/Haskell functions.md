<h2>Baby's first functions</h2>
<p>
In the previous section we got a basic feel for calling functions. Now let's try making our own! Open up your favorite text editor and punch in this function that takes a number and multiplies it by two.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>doubleMe&nbsp;x</span><span class="common_operators">&nbsp;=&nbsp;</span><span>x</span><span class="common_operators">&nbsp;+&nbsp;</span><span>x&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">doubleMe x = x + x</pre>
<p>
Functions are defined in a similar way that they are called. The function name is followed by parameters seperated by spaces. But when defining functions, there's a <span class="fixed">=</span> and after that we define what the function does. Save this as <span class="fixed">baby.hs</span> or something. Now navigate to where it's saved and run <span class="fixed">ghci</span> from there. Once inside GHCI, do <span class="fixed">:l baby</span>. Now that our script is loaded, we can play with the function that we defined.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;:l&nbsp;baby&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>&nbsp;</span><span class="keyword">of</span><span>&nbsp;</span><span class="numbers">1</span><span>]&nbsp;</span><span class="type_constructors">Compiling</span><span>&nbsp;</span><span class="type_constructors">Main</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;baby.hs,&nbsp;interpreted&nbsp;)&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="type_constructors">Ok</span><span>,&nbsp;modules&nbsp;loaded:&nbsp;</span><span class="type_constructors">Main</span><span>.&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;doubleMe&nbsp;</span><span class="numbers">9</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="numbers">18</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;doubleMe&nbsp;</span><span class="numbers">8.3</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="numbers">16.6</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 </pre>
<p>
Because <span class="fixed">+</span> works on integers as well as on floating-point numbers (anything that can be considered a number, really), our function also works on any number. Let's make a function that takes two numbers and multiplies each by two and then adds them together.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>doubleUs&nbsp;x&nbsp;y</span><span class="common_operators">&nbsp;=&nbsp;</span><span>x*</span><span class="numbers">2</span><span class="common_operators">&nbsp;+&nbsp;</span><span>y*</span><span class="numbers">2</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">doubleUs x y = x*2 + y*2 </pre>
<p>
Simple. We could have also defined it as <span class="fixed">doubleUs x y = x + x + y + y</span>. Testing it out produces pretty predictable results (remember to append this function to the <span class="fixed">baby.hs</span> file, save it and then do <span class="fixed">:l baby</span> inside GHCI).
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;doubleUs&nbsp;</span><span class="numbers">4</span><span>&nbsp;</span><span class="numbers">9</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">26</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;doubleUs&nbsp;</span><span class="numbers">2.3</span><span>&nbsp;</span><span class="numbers">34.2</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">73.0</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;doubleUs&nbsp;</span><span class="numbers">28</span><span>&nbsp;</span><span class="numbers">88</span><span class="common_operators">&nbsp;+&nbsp;</span><span>doubleMe&nbsp;</span><span class="numbers">123</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">478</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
</pre>
<p>
As expected, you can call your own functions from other functions that you made. With that in mind, we could redefine <span class="fixed">doubleUs</span> like this:
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>doubleUs&nbsp;x&nbsp;y</span><span class="common_operators">&nbsp;=&nbsp;</span><span>doubleMe&nbsp;x</span><span class="common_operators">&nbsp;+&nbsp;</span><span>doubleMe&nbsp;y&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">doubleUs x y = doubleMe x + doubleMe y </pre>
<p>
This is a very simple example of a common pattern you will see throughout Haskell. Making basic functions that are obviously correct and then combining them into more complex functions. This way you also avoid repetition. What if some mathematicians figured out that 2 is actually 3 and you had to change your program? You could just redefine <span class="fixed">doubleMe</span> to be <span class="fixed">x + x + x</span> and since <span class="fixed">doubleUs</span> calls <span class="fixed">doubleMe</span>, it would automatically work in this strange new world where 2 is 3.
</p>
<p>Functions in Haskell don't have to be in any particular order, so it doesn't matter if you define <span class="fixed">doubleMe</span> first and then  <span class="fixed">doubleUs</span> or if you do it the other way around.</p>
<p>Now we're going to make a function that multiplies a number by 2 but only if that number is smaller than or equal to 100 because numbers bigger than 100 are big enough as it is!
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>doubleSmallNumber&nbsp;x</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="keyword">if</span><span>&nbsp;x</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span class="numbers">100</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">then</span><span>&nbsp;x&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><span>&nbsp;x*</span><span class="numbers">2</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">doubleSmallNumber x = if x &gt; 100
                        then x
                        else x*2 </pre>
<img src="http://s3.amazonaws.com/lyah/baby.png" alt="this is you" class="left" width="140" height="211">
<p>
Right here we introduced Haskell's if statement. You're probably familiar with if statements from other languages. The difference between Haskell's if statement and if statements in imperative languages is that the else part is mandatory in Haskell. In imperative languages you can just skip a couple of steps if the condition isn't satisfied but in Haskell every expression and function must return something. We could have also written that if statement in one line but I find this way more readable. Another thing about the if statement in Haskell is that it is an <i>expression</i>. An expression is basically a piece of code that returns a value. <span class="fixed">5</span> is an expression because it returns 5, <span class="fixed">4 + 8</span> is an expression, <span class="fixed">x + y</span> is an expression because it returns the sum of <span class="fixed">x</span> and <span class="fixed">y</span>. Because the else is mandatory, an if statement will always return something and that's why it's an expression. If we wanted to add one to every number that's produced in our previous function, we could have written its body like this.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>doubleSmallNumber'&nbsp;x</span><span class="common_operators">&nbsp;=&nbsp;</span><span>(</span><span class="keyword">if</span><span>&nbsp;x</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span class="numbers">100</span><span>&nbsp;</span><span class="keyword">then</span><span>&nbsp;x&nbsp;</span><span class="keyword">else</span><span>&nbsp;x*</span><span class="numbers">2</span><span>)</span><span class="common_operators">&nbsp;+&nbsp;</span><span class="numbers">1</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1
</pre>
<p>
Had we omitted the parentheses, it would have added one only if <span class="fixed">x</span> wasn't greater than 100. Note the <span class="fixed">'</span> at the end of the function name. That apostrophe doesn't have any special meaning in Haskell's syntax. It's a valid character to use in a function name. We usually use <span class="fixed">'</span> to either denote a strict version of a function (one that isn't lazy) or a slightly modified version of a function or a variable. Because <span class="fixed">'</span> is a valid character in functions, we can make a function like this.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>conanO'</span><span class="type_constructors">Brien</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"It's&nbsp;a-me,&nbsp;Conan&nbsp;O'Brien!"</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">conanO'Brien = "It's a-me, Conan O'Brien!" </pre>
<p>
There are two noteworthy things here. The first is that in the function name we didn't capitalize Conan's name. That's because functions can't begin with uppercase letters. We'll see why a bit later. The second thing is that this function doesn't take any parameters. When a function doesn't take any parameters, we usually say it's a <i>definition</i> (or a <i>name</i>). Because we can't change what names (and functions) mean once we've defined them, <span class="fixed">conanO'Brien</span> and the string <span class="fixed">"It's a-me, Conan O'Brien!"</span> can be used interchangeably.
</p>