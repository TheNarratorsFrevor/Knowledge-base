<h2>An intro to lists</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/list.png" alt="BUY A DOG" class="left" width="150" height="103">
Much like shopping lists in the real world, lists in Haskell are very useful. It's the most used data structure and it can be used in a multitude of different ways to model and solve a whole bunch of problems. Lists are SO awesome. In this section we'll look at the basics of lists, strings (which are lists) and list comprehensions.
</p>
<p>
In Haskell, lists are a <em>homogenous</em> data structure. It stores several elements of the same type. That means that we can have a list of integers or a list of characters but we can't have a list that has a few integers and then a few characters. And now, a list!
</p>
<div class="hintbox"><em>Note</em>: We can use the <span class="fixed">let</span> keyword to define a name right in GHCI. Doing <span class="fixed">let a = 1</span> inside GHCI is the equivalent of writing <span class="fixed">a = 1</span> in a script and then loading it. </div>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;lostNumbers</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[</span><span class="numbers">4</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">15</span><span>,</span><span class="numbers">16</span><span>,</span><span class="numbers">23</span><span>,</span><span class="numbers">42</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;lostNumbers&nbsp;&nbsp;</span></span></li><li class="alt"><span>[<span class="numbers">4</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">15</span><span>,</span><span class="numbers">16</span><span>,</span><span class="numbers">23</span><span>,</span><span class="numbers">42</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]
</pre>
<p>
As you can see, lists are denoted by square brackets and the values in the lists are separated by commas. If we tried a list like <span class="fixed">[1,2,'a',3,'b','c',4]</span>, Haskell would complain that characters (which are, by the way, denoted as a character between single quotes) are not numbers. Speaking of characters, strings are just lists of characters. <span class="fixed">"hello"</span> is just syntactic sugar for <span class="fixed">['h','e','l','l','o']</span>. Because strings are lists, we can use list functions on them, which is really handy. 
</p>
<p>A common task is putting two lists together. This is done by using the <span class="fixed">++</span> operator. </p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>]</span><span class="common_operators">&nbsp;++&nbsp;</span><span>[</span><span class="numbers">9</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">11</span><span>,</span><span class="numbers">12</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">9</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">11</span><span>,</span><span class="numbers">12</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="string">"hello"</span><span class="common_operators">&nbsp;++&nbsp;</span><span class="string">"&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span class="string">"world"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"hello&nbsp;world"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="char">'w'</span><span>,</span><span class="char">'o'</span><span>]</span><span class="common_operators">&nbsp;++&nbsp;</span><span>[</span><span class="char">'o'</span><span>,</span><span class="char">'t'</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"woot"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; "hello" ++ " " ++ "world"
"hello world"
ghci&gt; ['w','o'] ++ ['o','t']
"woot"
</pre>
<p>
Watch out when repeatedly using the <span class="fixed">++</span> operator on long strings. When you put together two lists (even if you append a singleton list to a list, for instance: <span class="fixed">[1,2,3] ++ [4]</span>), internally, Haskell has to walk through the whole list on the left side of <span class="fixed">++</span>. That's not a problem when dealing with lists that aren't too big. But putting something at the end of a list that's fifty million entries long is going to take a while. However, putting something at the beginning of a list using the <span class="fixed">:</span> operator (also called the cons operator) is instantaneous.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="char">'A'</span><span>:</span><span class="string">"&nbsp;SMALL&nbsp;CAT"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"A&nbsp;SMALL&nbsp;CAT"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="numbers">5</span><span>:[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">5</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; 'A':" SMALL CAT"
"A SMALL CAT"
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]
</pre>
<p>
Notice how <span class="fixed">:</span> takes a number and a list of numbers or a character and a list of characters, whereas <span class="fixed">++</span> takes two lists. Even if you're adding an element to the end of a list with <span class="fixed">++</span>, you have to surround it with square brackets so it becomes a list. </p>
<p>
<span class="fixed">[1,2,3]</span> is actually just syntactic sugar for <span class="fixed">1:2:3:[]</span>. <span class="fixed">[]</span> is an empty list. If we prepend <span class="fixed">3</span> to it, it becomes <span class="fixed">[3]</span>. If we prepend <span class="fixed">2</span> to that, it becomes <span class="fixed">[2,3]</span>, and so on.
</p>
<p class="hintbox"><em>Note:</em> <span class="fixed">[]</span>, <span class="fixed">[[]]</span> and<span class="fixed">[[],[],[]]</span> are all different things. The first one is an empty list, the seconds one is a list that contains one empty list, the third one is a list that contains three empty lists.</p>
<p>If you want to get an element out of a list by index, use <span class="fixed">!!</span>. The indices start at 0.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="string">"Steve&nbsp;Buscemi"</span><span>&nbsp;!!&nbsp;</span><span class="numbers">6</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="char">'B'</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">9.4</span><span>,</span><span class="numbers">33.2</span><span>,</span><span class="numbers">96.2</span><span>,</span><span class="numbers">11.2</span><span>,</span><span class="numbers">23.25</span><span>]&nbsp;!!&nbsp;</span><span class="numbers">1</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">33.2</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; "Steve Buscemi" !! 6
'B'
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
</pre>
<p>But if you try to get the sixth element from a list that only has four elements, you'll get an error so be careful!</p>
<p>
Lists can also contain lists. They can also contain lists that contain lists that contain lists â€¦
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;b</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">5</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>]]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;b&nbsp;&nbsp;</span></span></li><li class="alt"><span>[[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">5</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>]]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;b</span><span class="common_operators">&nbsp;++&nbsp;</span><span>[[</span><span class="numbers">1</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">1</span><span>]]&nbsp;&nbsp;</span></span></li><li class="alt"><span>[[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">5</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">1</span><span>]]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">6</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">6</span><span>]:b&nbsp;&nbsp;</span></span></li><li class="alt"><span>[[<span class="numbers">6</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">6</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">5</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">3</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>]]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;b&nbsp;!!&nbsp;</span><span class="numbers">2</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !! 2
[1,2,2,3,4] </pre>
<p>The lists within a list can be of different lengths but they can't be of different types. Just like you can't have a list that has some characters and some numbers, you can't have a list that has some lists of characters and some lists of numbers.</p>
<p>Lists can be compared if the stuff they contain can be compared. When using <span class="fixed">&lt;</span>, <span class="fixed">&lt;=</span>, <span class="fixed">&gt;</span> and <span class="fixed">&gt;=</span> to compare lists, they are compared in lexicographical order. First the heads are compared. If they are equal then the second elements are compared, etc.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span>[</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">0</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">True</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span>[</span><span class="numbers">2</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">100</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">True</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>]</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span>[</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">True</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>]</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span>[</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">True</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>]</span><span class="common_operators">&nbsp;==&nbsp;</span><span>[</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">True</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &gt; [3,4]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True
</pre>
<p>
What else can you do with lists? Here are some basic functions that operate on lists.
</p>
<p><span class="label function">head</span> takes a list and returns its head. The head of a list is basically its first element.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;head&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">5</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; head [5,4,3,2,1]
5 </pre>
<p><span class="label function">tail</span> takes a list and returns its tail. In other words, it chops off a list's head.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;tail&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; tail [5,4,3,2,1]
[4,3,2,1] </pre>
<p><span class="label function">last</span> takes a list and returns its last element.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;last&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">1</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; last [5,4,3,2,1]
1 </pre>
<p><span class="label function">init</span> takes a list and returns everything except its last element.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;init&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; init [5,4,3,2,1]
[5,4,3,2] </pre>
<p>If we think of a list as a monster, here's what's what.</p>
<img src="http://s3.amazonaws.com/lyah/listmonster.png" alt="list monster" class="center" width="580" height="290">
<p>But what happens if we try to get the head of an empty list?</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;head&nbsp;[]&nbsp;&nbsp;</span></span></li><li class=""><span>***&nbsp;<span class="type_constructors">Exception</span><span>:&nbsp;</span><span class="type_constructors">Prelude</span><span>.head:&nbsp;empty&nbsp;list&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; head []
*** Exception: Prelude.head: empty list</pre>
<p>Oh my! It all blows up in our face! If there's no monster, it doesn't have a head. When using <span class="fixed">head</span>, <span class="fixed">tail</span>, <span class="fixed">last</span> and <span class="fixed">init</span>, be careful not to use them on empty lists. This error cannot be caught at compile time so it's always good practice to take precautions against accidentally telling Haskell to give you some elements from an empty list.
</p><p><span class="label function">length</span> takes a list and returns its length, obviously.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;length&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">5</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; length [5,4,3,2,1]
5</pre>
<p><span class="label function">null</span> checks if a list is empty. If it is, it returns <span class="fixed">True</span>, otherwise it returns <span class="fixed">False</span>. Use this function instead of <span class="fixed">xs == []</span> (if you have a list called <span class="fixed">xs</span>)</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;null&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">False</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;null&nbsp;[]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">True</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; null [1,2,3]
False
ghci&gt; null []
True</pre>
<p><span class="label function">reverse</span> reverses a list.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;reverse&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]</pre>
<p><span class="label function">take</span> takes number and a list. It extracts that many elements from the beginning of the list. Watch.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;take&nbsp;</span><span class="numbers">3</span><span>&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">3</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;take&nbsp;</span><span class="numbers">1</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">9</span><span>,</span><span class="numbers">3</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">3</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;take&nbsp;</span><span class="numbers">5</span><span>&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;take&nbsp;</span><span class="numbers">0</span><span>&nbsp;[</span><span class="numbers">6</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">6</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[]&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]</pre>
<p>See how if we try to take more elements than there are in the list, it just returns the list. If we try to take 0 elements, we get an empty list.</p>
<p><span class="label function">drop</span> works in a similar way, only it drops the number of elements from the beginning of a list.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;drop&nbsp;</span><span class="numbers">3</span><span>&nbsp;[</span><span class="numbers">8</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;drop&nbsp;</span><span class="numbers">0</span><span>&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;drop&nbsp;</span><span class="numbers">100</span><span>&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[]&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[] </pre>
<p><span class="label function">maximum</span> takes a list of stuff that can be put in some kind of order and returns the biggest element.</p><p> <span class="label function">minimum</span> returns the smallest.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;minimum&nbsp;[</span><span class="numbers">8</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">1</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;maximum&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">9</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">9</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; minimum [8,4,2,1,5,6]
1
ghci&gt; maximum [1,9,2,3,4]
9 </pre>
<p><span class="label function">sum</span> takes a list of numbers and returns their sum.</p><p><span class="label function">product</span> takes a list of numbers and returns their product.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;sum&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">7</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">31</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;product&nbsp;[</span><span class="numbers">6</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">24</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;product&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">7</span><span>,</span><span class="numbers">9</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">0</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">0</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0 </pre>
<p><span class="label function">elem</span> takes a thing and a list of things and tells us if that thing is an element of the list. It's usually called as an infix function because it's easier to read that way.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="numbers">4</span><span>&nbsp;</span><span class="common_operators">`elem`</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">True</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="numbers">10</span><span>&nbsp;</span><span class="common_operators">`elem`</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">False</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False
</pre>
<p>Those were a few basic functions that operate on lists. We'll take a look at more list functions <a href="modules#data-list">later</a></p>
<a name="texas-ranges"></a><h2>Texas ranges</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/cowboy.png" alt="draw" class="right" width="200" height="258">
What if we want a list of all numbers between 1 and 20? Sure, we could just type them all out but obviously that's not a solution for gentlemen who demand excellence from their programming languages. Instead, we'll use ranges. Ranges are a way of making lists that are arithmetic sequences of elements that can be enumerated. Numbers can be enumerated. One, two, three, four, etc. Characters can also be enumerated. The alphabet is an enumeration of characters from A to Z. Names can't be enumerated. What comes after "John"? I don't know.
</p>
<p>To make a list containing all the natural numbers from 1 to 20, you just write <span class="fixed">[1..20]</span>. That is the equivalent of writing <span class="fixed">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</span> and there's no difference between writing one or the other except that writing out long enumeration sequences manually is stupid.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">1</span><span>..</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">7</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">9</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">11</span><span>,</span><span class="numbers">12</span><span>,</span><span class="numbers">13</span><span>,</span><span class="numbers">14</span><span>,</span><span class="numbers">15</span><span>,</span><span class="numbers">16</span><span>,</span><span class="numbers">17</span><span>,</span><span class="numbers">18</span><span>,</span><span class="numbers">19</span><span>,</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="char">'a'</span><span>..</span><span class="char">'z'</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"abcdefghijklmnopqrstuvwxyz"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="char">'K'</span><span>..</span><span class="char">'Z'</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"KLMNOPQRSTUVWXYZ"</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; ['K'..'Z']
"KLMNOPQRSTUVWXYZ" </pre>
<p>
Ranges are cool because you can also specify a step. What if we want all even numbers between 1 and 20? Or every third number between 1 and 20?
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>..</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">12</span><span>,</span><span class="numbers">14</span><span>,</span><span class="numbers">16</span><span>,</span><span class="numbers">18</span><span>,</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">3</span><span>,</span><span class="numbers">6</span><span>..</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">3</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">9</span><span>,</span><span class="numbers">12</span><span>,</span><span class="numbers">15</span><span>,</span><span class="numbers">18</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18] </pre>
<p>It's simply a matter of separating the first two elements with a comma and then specifying what the upper limit is. While pretty smart, ranges with steps aren't as smart as some people expect them to be. You can't do <span class="fixed">[1,2,4,8,16..100]</span> and expect to get all the powers of 2. Firstly because you can only specify one step. And secondly because some sequences that aren't arithmetic are ambiguous if given only by a few of their first terms.
</p>
<p>To make a list with all the numbers from 20 to 1, you can't just do <span class="fixed">[20..1]</span>, you have to do <span class="fixed">[20,19..1]</span>.</p>
<p>Watch out when using floating point numbers in ranges! Because they are not completely precise (by definition), their use in ranges can yield some pretty funky results.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[</span><span class="numbers">0.1</span><span>,&nbsp;</span><span class="numbers">0.3</span><span>&nbsp;..&nbsp;</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">0.1</span><span>,</span><span class="numbers">0.3</span><span>,</span><span class="numbers">0.5</span><span>,</span><span class="numbers">0.7</span><span>,</span><span class="numbers">0.8999999999999999</span><span>,</span><span class="numbers">1.0999999999999999</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
</pre>
<p>My advice is not to use them in list ranges.</p>
<p>
You can also use ranges to make infinite lists by just not specifying an upper limit. Later we'll go into more detail on infinite lists. For now, let's examine how you would get the first 24 multiples of 13. Sure, you could do <span class="fixed">[13,26..24*13]</span>. But there's a better way: <span class="fixed">take 24 [13,26..]</span>. Because Haskell is lazy, it won't try to evaluate the infinite list immediately because it would never finish. It'll wait to see what you want to get out of that infinite lists. And here it sees you just want the first 24 elements and it gladly obliges.
</p>
<p>A handful of functions that produce infinite lists:</p>
<p><span class="label function">cycle</span> takes a list and cycles it into an infinite list. If you just try to display the result, it will go on forever so you have to slice it off somewhere.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;take&nbsp;</span><span class="numbers">10</span><span>&nbsp;(cycle&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>])&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">1</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;take&nbsp;</span><span class="numbers">12</span><span>&nbsp;(cycle&nbsp;</span><span class="string">"LOL&nbsp;"</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"LOL&nbsp;LOL&nbsp;LOL&nbsp;"</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle "LOL ")
"LOL LOL LOL " </pre>
<p><span class="label function">repeat</span> takes an element and produces an infinite list of just that element. It's like cycling a list with only one element.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;take&nbsp;</span><span class="numbers">10</span><span>&nbsp;(repeat&nbsp;</span><span class="numbers">5</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
</pre>
<p>Although it's simpler to just use the <span class="label function">replicate</span> function if you want some number of the same element in a list. <span class="fixed">replicate 3 10</span> returns <span class="fixed">[10,10,10]</span>.</p>
<a name="im-a-list-comprehension"></a><h2>I'm a list comprehension</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/kermit.png" alt="frog" class="left" width="180" height="156">
If you've ever taken a course in mathematics, you've probably run into <i>set comprehensions</i>. They're normally used for building more specific sets out of general sets. A basic comprehension for a set that contains the first ten even natural numbers is <img src="http://s3.amazonaws.com/lyah/setnotation.png" alt="set notation">. The part before the pipe is called the output function, <span class="fixed">x</span> is the variable, <span class="fixed">N</span> is the input set and <span class="fixed">x &lt;= 10</span> is the predicate. That means that the set contains the doubles of all natural numbers that satisfy the predicate.
</p>
<p>If we wanted to write that in Haskell, we could do something like <span class="fixed">take 10 [2,4..]</span>. But what if we didn't want doubles of the first 10 natural numbers but some kind of more complex function applied on them? We could use a list comprehension for that. List comprehensions are very similar to set comprehensions. We'll stick to getting the first 10 even numbers for now. The list comprehension we could use is <span class="fixed">[x*2 | x &lt;- [1..10]]</span>. <span class="fixed">x</span> is drawn from <span class="fixed">[1..10]</span> and for every element in <span class="fixed">[1..10]</span> (which we have bound to <span class="fixed">x</span>), we get that element, only doubled. Here's that comprehension in action. </p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[x*</span><span class="numbers">2</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..</span><span class="numbers">10</span><span>]]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">12</span><span>,</span><span class="numbers">14</span><span>,</span><span class="numbers">16</span><span>,</span><span class="numbers">18</span><span>,</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [x*2 | x &lt;- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
</pre>
<p>As you can see, we get the desired results. Now let's add a condition (or a predicate) to that comprehension. Predicates go after the binding parts and are separated from them by a comma. Let's say we want only the elements which, doubled, are greater than or equal to 12.
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[x*</span><span class="numbers">2</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..</span><span class="numbers">10</span><span>],&nbsp;x*</span><span class="numbers">2</span><span class="common_operators">&nbsp;&gt;=&nbsp;</span><span class="numbers">12</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">12</span><span>,</span><span class="numbers">14</span><span>,</span><span class="numbers">16</span><span>,</span><span class="numbers">18</span><span>,</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12]
[12,14,16,18,20]
</pre>
<p>Cool, it works. How about if we wanted all numbers from 50 to 100 whose remainder when divided with the number 7 is 3? Easy.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[&nbsp;x</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">50</span><span>..</span><span class="numbers">100</span><span>],&nbsp;x&nbsp;</span><span class="common_operators">`mod`</span><span>&nbsp;</span><span class="numbers">7</span><span class="common_operators">&nbsp;==&nbsp;</span><span class="numbers">3</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">52</span><span>,</span><span class="numbers">59</span><span>,</span><span class="numbers">66</span><span>,</span><span class="numbers">73</span><span>,</span><span class="numbers">80</span><span>,</span><span class="numbers">87</span><span>,</span><span class="numbers">94</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] </pre>
<p>Success! Note that weeding out lists by predicates is also called <em>filtering</em>. We took a list of numbers and we filtered them by the predicate. Now for another example. Let's say we want a comprehension that replaces each odd number greater than 10 with <span class="fixed">"BANG!"</span> and each odd number that's less than 10 with <span class="fixed">"BOOM!"</span>. If a number isn't odd, we throw it out of our list. For convenience, we'll put that comprehension inside a function so we can easily reuse it.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>boomBangs&nbsp;xs</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[&nbsp;</span><span class="keyword">if</span><span>&nbsp;x</span><span class="common_operators">&nbsp;&lt;&nbsp;</span><span class="numbers">10</span><span>&nbsp;</span><span class="keyword">then</span><span>&nbsp;</span><span class="string">"BOOM!"</span><span>&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="string">"BANG!"</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>xs,&nbsp;odd&nbsp;x]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">boomBangs xs = [ if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] </pre>
<p>The last part of the comprehension is the predicate. The function <span class="fixed">odd</span> returns <span class="fixed">True</span> on an odd number and <span class="fixed">False</span>  on an even one. The element is included in the list only if all the predicates evaluate to <span class="fixed">True</span>.
</p><div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;boomBangs&nbsp;[</span><span class="numbers">7</span><span>..</span><span class="numbers">13</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="string">"BOOM!"</span><span>,</span><span class="string">"BOOM!"</span><span>,</span><span class="string">"BANG!"</span><span>,</span><span class="string">"BANG!"</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">ghci&gt; boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] </pre>
<p>We can include several predicates. If we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we'd do:</p> <div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[&nbsp;x</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">10</span><span>..</span><span class="numbers">20</span><span>],&nbsp;x</span><span class="common_operators">&nbsp;/=&nbsp;</span><span class="numbers">13</span><span>,&nbsp;x</span><span class="common_operators">&nbsp;/=&nbsp;</span><span class="numbers">15</span><span>,&nbsp;x</span><span class="common_operators">&nbsp;/=&nbsp;</span><span class="numbers">19</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">10</span><span>,</span><span class="numbers">11</span><span>,</span><span class="numbers">12</span><span>,</span><span class="numbers">14</span><span>,</span><span class="numbers">16</span><span>,</span><span class="numbers">17</span><span>,</span><span class="numbers">18</span><span>,</span><span class="numbers">20</span><span>]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]</pre>
<p>Not only can we have multiple predicates in list comprehensions (an element must satisfy all the predicates to be included in the resulting list), we can also draw from several lists. When drawing from several lists, comprehensions produce all combinations of the given lists and then join them by the output function we supply. A list produced by a comprehension that draws from two lists of length 4 will have a length of 16, provided we don't filter them. If we have two lists, <span class="fixed">[2,5,10]</span> and <span class="fixed">[8,10,11]</span> and we want to get the products of all the possible combinations between numbers in those lists, here's what we'd do.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[&nbsp;x*y</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">2</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">10</span><span>],&nbsp;y</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">8</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">11</span><span>]]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">16</span><span>,</span><span class="numbers">20</span><span>,</span><span class="numbers">22</span><span>,</span><span class="numbers">40</span><span>,</span><span class="numbers">50</span><span>,</span><span class="numbers">55</span><span>,</span><span class="numbers">80</span><span>,</span><span class="numbers">100</span><span>,</span><span class="numbers">110</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110] </pre>
<p>As expected, the length of the new list is 9. What if we wanted all possible products that are more than 50?</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[&nbsp;x*y</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">2</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">10</span><span>],&nbsp;y</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">8</span><span>,</span><span class="numbers">10</span><span>,</span><span class="numbers">11</span><span>],&nbsp;x*y</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span class="numbers">50</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="numbers">55</span><span>,</span><span class="numbers">80</span><span>,</span><span class="numbers">100</span><span>,</span><span class="numbers">110</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110] </pre>
<p>How about a list comprehension that combines a list of adjectives and a list of nouns â€¦ for epic hilarity.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;nouns</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[</span><span class="string">"hobo"</span><span>,</span><span class="string">"frog"</span><span>,</span><span class="string">"pope"</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;adjectives</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[</span><span class="string">"lazy"</span><span>,</span><span class="string">"grouchy"</span><span>,</span><span class="string">"scheming"</span><span>]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;[adjective</span><span class="common_operators">&nbsp;++&nbsp;</span><span class="string">"&nbsp;"</span><span class="common_operators">&nbsp;++&nbsp;</span><span>noun</span><span class="common_operators">&nbsp;|&nbsp;</span><span>adjective</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>adjectives,&nbsp;noun</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>nouns]&nbsp;&nbsp;</span></span></li><li class=""><span>[<span class="string">"lazy&nbsp;hobo"</span><span>,</span><span class="string">"lazy&nbsp;frog"</span><span>,</span><span class="string">"lazy&nbsp;pope"</span><span>,</span><span class="string">"grouchy&nbsp;hobo"</span><span>,</span><span class="string">"grouchy&nbsp;frog"</span><span>,&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="string">"grouchy&nbsp;pope"</span><span>,</span><span class="string">"scheming&nbsp;hobo"</span><span>,</span><span class="string">"scheming&nbsp;frog"</span><span>,</span><span class="string">"scheming&nbsp;pope"</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let nouns = ["hobo","frog","pope"]
ghci&gt; let adjectives = ["lazy","grouchy","scheming"]
ghci&gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] </pre>
<p>I know! Let's write our own version of <span class="fixed">length</span>! We'll call it <span class="fixed">length'</span>.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>length'&nbsp;xs</span><span class="common_operators">&nbsp;=&nbsp;</span><span>sum&nbsp;[</span><span class="numbers">1</span><span class="common_operators">&nbsp;|&nbsp;</span><span>_</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>xs]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">length' xs = sum [1 | _ &lt;- xs] </pre>
<p><span class="fixed">_</span> means that we don't care what we'll draw from the list anyway so instead of writing a variable name that we'll never use, we just write <span class="fixed">_</span>. This function replaces every element of a list with <span class="fixed">1</span> and then sums that up. This means that the resulting sum will be the length of our list.</p>
<p>Just a friendly reminder: because strings are lists, we can use list comprehensions to process and produce strings. Here's a function that takes a string and removes everything except uppercase letters from it.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>removeNonUppercase&nbsp;st</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[&nbsp;c</span><span class="common_operators">&nbsp;|&nbsp;</span><span>c</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>st,&nbsp;c&nbsp;</span><span class="common_operators">`elem`</span><span>&nbsp;[</span><span class="char">'A'</span><span>..</span><span class="char">'Z'</span><span>]]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: hs" style="display: none;">removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] </pre>
<p>
Testing it out:
</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;removeNonUppercase&nbsp;</span><span class="string">"Hahaha!&nbsp;Ahahaha!"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"HA"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;removeNonUppercase&nbsp;</span><span class="string">"IdontLIKEFROGS"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"ILIKEFROGS"</span><span>&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci&gt; removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" </pre>
<p>The predicate here does all the work. It says that the character will be included in the new list only if it's an element of the list <span class="fixed">['A'..'Z']</span>. Nested list comprehensions are also possible if you're operating on lists that contain lists. A list contains several lists of numbers. Let's remove all odd numbers without flattening the list.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;xxs</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[[</span><span class="numbers">1</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">7</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">9</span><span>],[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">1</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">6</span><span>]]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;[&nbsp;[&nbsp;x</span><span class="common_operators">&nbsp;|&nbsp;</span><span>x</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>xs,&nbsp;even&nbsp;x&nbsp;]</span><span class="common_operators">&nbsp;|&nbsp;</span><span>xs</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>xxs]&nbsp;&nbsp;</span></span></li><li class="alt"><span>[[<span class="numbers">2</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>],[</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">8</span><span>],[</span><span class="numbers">2</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">6</span><span>]]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
</pre>
<p>You can write list comprehensions across several lines. So if you're not in GHCI, it's better to split longer list comprehensions across multiple lines, especially if they're nested.</p>
<a name="tuples"></a><h2>Tuples</h2>
<img src="http://s3.amazonaws.com/lyah/tuple.png" alt="tuples" class="right" width="160" height="162">
<p>In some ways, tuples are like lists â€” they are a way to store several values into a single value. However, there are a few fundamental differences. A list of numbers is a list of numbers. That's its type and it doesn't matter if it has only one number in it or an infinite amount of numbers. Tuples, however, are used when you know exactly how many values you want to combine and its type depends on how many components it has and the types of the components. They are denoted with parentheses and their components are separated by commas.</p>
<p>Another key difference is that they don't have to be homogenous. Unlike a list, a tuple can contain a combination of several types.</p>
<p>Think about how we'd represent a two-dimensional vector in Haskell. One way would be to use a list. That would kind of work. So what if we wanted to put a couple of vectors in a list to represent points of a shape on a two-dimensional plane? We could do something like <span class="fixed">[[1,2],[8,11],[4,5]]</span>. The problem with that method is that we could also do stuff like <span class="fixed">[[1,2],[8,11,5],[4,5]]</span>, which Haskell has no problem with since it's still a list of lists with numbers but it kind of doesn't make sense. But a tuple of size two (also called a pair) is its own type, which means that a list can't have a couple of pairs in it and then a triple (a tuple of size three), so let's use that instead. Instead of surrounding the vectors with square brackets, we use parentheses: <span class="fixed">[(1,2),(8,11),(4,5)]</span>. What if we tried to make a shape like <span class="fixed">[(1,2),(8,11,5),(4,5)]</span>? Well, we'd get this error:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="type_constructors">Couldn</span><span>'t&nbsp;match&nbsp;expected&nbsp;</span><span class="keyword2">type</span><span>&nbsp;`(t,&nbsp;t1)'&nbsp;&nbsp;</span></span></li><li class=""><span>against&nbsp;inferred&nbsp;<span class="keyword2">type</span><span>&nbsp;`(t2,&nbsp;t3,&nbsp;t4)'&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="type_constructors">In</span><span>&nbsp;the&nbsp;expression:&nbsp;(</span><span class="numbers">8</span><span>,&nbsp;</span><span class="numbers">11</span><span>,&nbsp;</span><span class="numbers">5</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">In</span><span>&nbsp;the&nbsp;expression:&nbsp;[(</span><span class="numbers">1</span><span>,&nbsp;</span><span class="numbers">2</span><span>),&nbsp;(</span><span class="numbers">8</span><span>,&nbsp;</span><span class="numbers">11</span><span>,&nbsp;</span><span class="numbers">5</span><span>),&nbsp;(</span><span class="numbers">4</span><span>,&nbsp;</span><span class="numbers">5</span><span>)]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="type_constructors">In</span><span>&nbsp;the&nbsp;definition&nbsp;</span><span class="keyword">of</span><span>&nbsp;`it':&nbsp;it</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[(</span><span class="numbers">1</span><span>,&nbsp;</span><span class="numbers">2</span><span>),&nbsp;(</span><span class="numbers">8</span><span>,&nbsp;</span><span class="numbers">11</span><span>,&nbsp;</span><span class="numbers">5</span><span>),&nbsp;(</span><span class="numbers">4</span><span>,&nbsp;</span><span class="numbers">5</span><span>)]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
</pre>
<p>It's telling us that we tried to use a pair and a triple in the same list, which is not supposed to happen. You also couldn't make a list like <span class="fixed">[(1,2),("One",2)]</span> because the first element of the list is a pair of numbers and the second element is a pair consisting of a string and a number. Tuples can also be used to represent a wide variety of data. For instance, if we wanted to represent someone's name and age in Haskell, we could use a triple: <span class="fixed">("Christopher", "Walken", 55)</span>. As seen in this example, tuples can also contain lists.</p>
<p>Use tuples when you know in advance how many components some piece of data should have. Tuples are much more rigid because each different size of tuple is its own type, so you can't write a general function to append an element to a tuple â€” you'd have to write a function for appending to a pair, one function for appending to a triple, one function for appending to a 4-tuple, etc.</p>
<p>While there are singleton lists, there's no such thing as a singleton tuple. It doesn't really make much sense when you think about it. A singleton tuple would just be the value it contains and as such would have no benefit to us.</p>
<p>Like lists, tuples can be compared with each other if their components can be compared. Only you can't compare two tuples of different sizes, whereas you can compare two lists of different sizes. Two useful functions that operate on pairs:</p>
<p><span class="label function">fst</span> takes a pair and returns its first component.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;fst&nbsp;(</span><span class="numbers">8</span><span>,</span><span class="numbers">11</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">8</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;fst&nbsp;(</span><span class="string">"Wow"</span><span>,&nbsp;</span><span class="type_constructors">False</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"Wow"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; fst (8,11)
8
ghci&gt; fst ("Wow", False)
"Wow"</pre>
<p><span class="label function">snd</span> takes a pair and returns its second component. Surprise!</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;snd&nbsp;(</span><span class="numbers">8</span><span>,</span><span class="numbers">11</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span><span class="numbers">11</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;snd&nbsp;(</span><span class="string">"Wow"</span><span>,&nbsp;</span><span class="type_constructors">False</span><span>)&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">False</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; snd (8,11)
11
ghci&gt; snd ("Wow", False)
False</pre>
<div class="hintbox"><em>Note:</em> these functions operate only on pairs. They won't work on triples, 4-tuples, 5-tuples, etc. We'll go over extracting data from tuples in different ways a bit later.</div>
<p>A cool function that produces a list of pairs: <span class="label function">zip</span>. It takes two lists and then zips them together into one list by joining the matching elements into pairs. It's a really simple function but it has loads of uses. It's especially useful for when you want to combine two lists in a way or traverse two lists simultaneously. Here's a demonstration.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;zip&nbsp;[</span><span class="numbers">1</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>]&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[(<span class="numbers">1</span><span>,</span><span class="numbers">5</span><span>),(</span><span class="numbers">2</span><span>,</span><span class="numbers">5</span><span>),(</span><span class="numbers">3</span><span>,</span><span class="numbers">5</span><span>),(</span><span class="numbers">4</span><span>,</span><span class="numbers">5</span><span>),(</span><span class="numbers">5</span><span>,</span><span class="numbers">5</span><span>)]&nbsp;&nbsp;</span></span></li><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;zip&nbsp;[</span><span class="numbers">1</span><span>&nbsp;..&nbsp;</span><span class="numbers">5</span><span>]&nbsp;[</span><span class="string">"one"</span><span>,&nbsp;</span><span class="string">"two"</span><span>,&nbsp;</span><span class="string">"three"</span><span>,&nbsp;</span><span class="string">"four"</span><span>,&nbsp;</span><span class="string">"five"</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[(<span class="numbers">1</span><span>,</span><span class="string">"one"</span><span>),(</span><span class="numbers">2</span><span>,</span><span class="string">"two"</span><span>),(</span><span class="numbers">3</span><span>,</span><span class="string">"three"</span><span>),(</span><span class="numbers">4</span><span>,</span><span class="string">"four"</span><span>),(</span><span class="numbers">5</span><span>,</span><span class="string">"five"</span><span>)]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
</pre>
<p>It pairs up the elements and produces a new list. The first element goes with the first, the second with the second, etc. Notice that because pairs can have different types in them, <span class="fixed">zip</span> can take two lists that contain different types and zip them up. What happens if the lengths of the lists don't match?</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;zip&nbsp;[</span><span class="numbers">5</span><span>,</span><span class="numbers">3</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">7</span><span>,</span><span class="numbers">2</span><span>,</span><span class="numbers">5</span><span>,</span><span class="numbers">4</span><span>,</span><span class="numbers">6</span><span>,</span><span class="numbers">6</span><span>]&nbsp;[</span><span class="string">"im"</span><span>,</span><span class="string">"a"</span><span>,</span><span class="string">"turtle"</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[(<span class="numbers">5</span><span>,</span><span class="string">"im"</span><span>),(</span><span class="numbers">3</span><span>,</span><span class="string">"a"</span><span>),(</span><span class="numbers">2</span><span>,</span><span class="string">"turtle"</span><span>)]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
</pre>
<p>The longer list simply gets cut off to match the length of the shorter one. Because Haskell is lazy, we can zip finite lists with infinite lists:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;zip&nbsp;[</span><span class="numbers">1</span><span>..]&nbsp;[</span><span class="string">"apple"</span><span>,&nbsp;</span><span class="string">"orange"</span><span>,&nbsp;</span><span class="string">"cherry"</span><span>,&nbsp;</span><span class="string">"mango"</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span>[(<span class="numbers">1</span><span>,</span><span class="string">"apple"</span><span>),(</span><span class="numbers">2</span><span>,</span><span class="string">"orange"</span><span>),(</span><span class="numbers">3</span><span>,</span><span class="string">"cherry"</span><span>),(</span><span class="numbers">4</span><span>,</span><span class="string">"mango"</span><span>)]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
</pre>
<img src="http://s3.amazonaws.com/lyah/pythag.png" alt="look at meee" class="center" width="350" height="315">
<p>Here's a problem that combines tuples and list comprehensions: which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24? First, let's try generating all triangles with sides equal to or smaller than 10:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;triangles</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[&nbsp;(a,b,c)</span><span class="common_operators">&nbsp;|&nbsp;</span><span>c</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..</span><span class="numbers">10</span><span>],&nbsp;b</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..</span><span class="numbers">10</span><span>],&nbsp;a</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..</span><span class="numbers">10</span><span>]&nbsp;]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ] </pre>
<p>We're just drawing from three lists and our output function is combining them into a triple. If you evaluate that by typing out <span class="fixed">triangles</span> in GHCI, you'll get a list of all possible triangles with sides under or equal to 10. Next, we'll add a condition that they all have to be right triangles. We'll also modify this function by taking into consideration that side b isn't larger than the hypothenuse and that side a isn't larger than side b.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;rightTriangles</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[&nbsp;(a,b,c)</span><span class="common_operators">&nbsp;|&nbsp;</span><span>c</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..</span><span class="numbers">10</span><span>],&nbsp;b</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..c],&nbsp;a</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..b],&nbsp;a^</span><span class="numbers">2</span><span class="common_operators">&nbsp;+&nbsp;</span><span>b^</span><span class="numbers">2</span><span class="common_operators">&nbsp;==&nbsp;</span><span>c^</span><span class="numbers">2</span><span>]&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2] </pre>
<p>We're almost done. Now, we just modify the function by saying that we want the ones where the perimeter is 24.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="keyword">let</span><span>&nbsp;rightTriangles'</span><span class="common_operators">&nbsp;=&nbsp;</span><span>[&nbsp;(a,b,c)</span><span class="common_operators">&nbsp;|&nbsp;</span><span>c</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..</span><span class="numbers">10</span><span>],&nbsp;b</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..c],&nbsp;a</span><span class="syntax_operators">&nbsp;&lt;-&nbsp;</span><span>[</span><span class="numbers">1</span><span>..b],&nbsp;a^</span><span class="numbers">2</span><span class="common_operators">&nbsp;+&nbsp;</span><span>b^</span><span class="numbers">2</span><span class="common_operators">&nbsp;==&nbsp;</span><span>c^</span><span class="numbers">2</span><span>,&nbsp;a+b+c</span><span class="common_operators">&nbsp;==&nbsp;</span><span class="numbers">24</span><span>]&nbsp;&nbsp;</span></span></li><li class=""><span><span class="ghci">ghci&gt;</span><span>&nbsp;rightTriangles'&nbsp;&nbsp;</span></span></li><li class="alt"><span>[(<span class="numbers">6</span><span>,</span><span class="numbers">8</span><span>,</span><span class="numbers">10</span><span>)]&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell: ghci" style="display: none;">ghci&gt; let rightTriangles' = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles'
[(6,8,10)]
</pre>
<p>And there's our answer! This is a common pattern in functional programming. You take a starting set of solutions and then you apply transformations to those solutions and filter them until you get the right ones.</p>