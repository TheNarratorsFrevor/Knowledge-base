<h2>Guards, guards!</h2>
<img src="http://s3.amazonaws.com/lyah/guards.png" alt="guards" class="left" width="83" height="180">
<p>Whereas patterns are a way of making sure a value conforms to some form and deconstructing it, guards are a way of testing whether some property of a value (or several of them) are true or false. That sounds a lot like an if statement and it's very similar. The thing is that guards are a lot more readable when you have several conditions and they play really nicely with patterns.</p>
<p>Instead of explaining their syntax, let's just dive in and make a function using guards. We're going to make a simple function that berates you differently depending on your <a href="http://en.wikipedia.org/wiki/Body_mass_index">BMI</a> (body mass index). Your BMI equals your weight divided by your height squared. If your BMI is less than 18.5, you're considered underweight. If it's anywhere from 18.5 to 25 then you're considered normal. 25 to 30 is overweight and more than 30 is obese. So here's the function (we won't be calculating it right now, this function just gets a BMI and tells you off)</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>bmiTell</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">RealFloat</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">String</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>bmiTell&nbsp;bmi&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>bmi</span><span class="common_operators">&nbsp;&lt;=&nbsp;</span><span class="numbers">18.5</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;underweight,&nbsp;you&nbsp;emo,&nbsp;you!"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>bmi</span><span class="common_operators">&nbsp;&lt;=&nbsp;</span><span class="numbers">25.0</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;supposedly&nbsp;normal.&nbsp;Pffft,&nbsp;I&nbsp;bet&nbsp;you're&nbsp;ugly!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>bmi</span><span class="common_operators">&nbsp;&lt;=&nbsp;</span><span class="numbers">30.0</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;fat!&nbsp;Lose&nbsp;some&nbsp;weight,&nbsp;fatty!"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>otherwise&nbsp;&nbsp;</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;a&nbsp;whale,&nbsp;congratulations!"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">bmiTell :: (RealFloat a) =&gt; a -&gt; String
bmiTell bmi
    | bmi &lt;= 18.5 = "You're underweight, you emo, you!"
    | bmi &lt;= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi &lt;= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise   = "You're a whale, congratulations!"
</pre>
<p>Guards are indicated by pipes that follow a function's name and its parameters. Usually, they're indented a bit to the right and lined up. A guard is basically a boolean expression. If it evaluates to <span class="fixed">True</span>, then the corresponding function body is used. If it evaluates to <span class="fixed">False</span>, checking drops through to the next guard and so on. If we call this function with <span class="fixed">24.3</span>, it will first check if that's smaller than or equal to <span class="fixed">18.5</span>. Because it isn't, it falls through to the next guard. The check is carried out with the second guard and because 24.3 is less than 25.0, the second string is returned.</p>
<p>This is very reminiscent of a big if else tree in imperative languages, only this is far better and more readable. While big if else trees are usually frowned upon, sometimes a problem is defined in such a discrete way that you can't get around them. Guards are a very nice alternative for this.</p>
<p>Many times, the last guard is <span class="fixed">otherwise</span>. <span class="fixed">otherwise</span> is defined simply as <span class="fixed">otherwise = True</span> and catches everything. This is very similar to patterns, only they check if the input satisfies a pattern but guards check for boolean conditions. If all the guards of a function evaluate to <span class="fixed">False</span> (and we haven't provided an <span class="fixed">otherwise</span> catch-all guard), evaluation falls through to the next <em>pattern</em>. That's how patterns and guards play nicely together. If no suitable guards or patterns are found, an error is thrown.</p>
<p>Of course we can use guards with functions that take as many parameters as we want. Instead of having the user calculate his own BMI before calling the function, let's modify this function so that it takes a height and weight and calculates it for us.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>bmiTell</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">RealFloat</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">String</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>bmiTell&nbsp;weight&nbsp;height&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>weight</span><span class="common_operators">&nbsp;/&nbsp;</span><span>height</span><span class="common_operators">&nbsp;^&nbsp;</span><span class="numbers">2</span><span class="common_operators">&nbsp;&lt;=&nbsp;</span><span class="numbers">18.5</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;underweight,&nbsp;you&nbsp;emo,&nbsp;you!"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>weight</span><span class="common_operators">&nbsp;/&nbsp;</span><span>height</span><span class="common_operators">&nbsp;^&nbsp;</span><span class="numbers">2</span><span class="common_operators">&nbsp;&lt;=&nbsp;</span><span class="numbers">25.0</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;supposedly&nbsp;normal.&nbsp;Pffft,&nbsp;I&nbsp;bet&nbsp;you're&nbsp;ugly!"</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>weight</span><span class="common_operators">&nbsp;/&nbsp;</span><span>height</span><span class="common_operators">&nbsp;^&nbsp;</span><span class="numbers">2</span><span class="common_operators">&nbsp;&lt;=&nbsp;</span><span class="numbers">30.0</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;fat!&nbsp;Lose&nbsp;some&nbsp;weight,&nbsp;fatty!"</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="string">"You're&nbsp;a&nbsp;whale,&nbsp;congratulations!"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String
bmiTell weight height
    | weight / height ^ 2 &lt;= 18.5 = "You're underweight, you emo, you!"
    | weight / height ^ 2 &lt;= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | weight / height ^ 2 &lt;= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise                 = "You're a whale, congratulations!"
</pre>
<p>Let's see if I'm fat ...</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;bmiTell&nbsp;</span><span class="numbers">85</span><span>&nbsp;</span><span class="numbers">1.90</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="string">"You're&nbsp;supposedly&nbsp;normal.&nbsp;Pffft,&nbsp;I&nbsp;bet&nbsp;you're&nbsp;ugly!"</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:ghci" style="display: none;">ghci&gt; bmiTell 85 1.90
"You're supposedly normal. Pffft, I bet you're ugly!"
</pre>
<p>Yay! I'm not fat! But Haskell just called me ugly. Whatever!</p>
<p>Note that there's no <span class="fixed">=</span> right after the function name and its parameters, before the first guard. Many newbies get syntax errors because they sometimes put it there.</p>
<p>Another very simple example: let's implement our own <span class="fixed">max</span> function. If you remember, it takes two things that can be compared and returns the larger of them.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>max'</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Ord</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>max'&nbsp;a&nbsp;b&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>a</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span>b&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="common_operators">&nbsp;=&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>otherwise</span><span class="common_operators">&nbsp;=&nbsp;</span><span>b&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">max' :: (Ord a) =&gt; a -&gt; a -&gt; a
max' a b 
    | a &gt; b     = a
    | otherwise = b
</pre>
<p>Guards can also be written inline, although I'd advise against that because it's less readable, even for very short functions. But to demonstrate, we could write <span class="fixed">max'</span> like this:</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>max'</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Ord</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a&nbsp;&nbsp;</span></span></li><li class=""><span>max'&nbsp;a&nbsp;b<span class="common_operators">&nbsp;|&nbsp;</span><span>a</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span>b</span><span class="common_operators">&nbsp;=&nbsp;</span><span>a</span><span class="common_operators">&nbsp;|&nbsp;</span><span>otherwise</span><span class="common_operators">&nbsp;=&nbsp;</span><span>b&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">max' :: (Ord a) =&gt; a -&gt; a -&gt; a
max' a b | a &gt; b = a | otherwise = b
</pre>

<p>Ugh! Not very readable at all! Moving on: let's implement our own <span class="fixed">compare</span> by using guards.</p>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span>myCompare</span><span class="syntax_operators">&nbsp;::&nbsp;</span><span>(</span><span class="type_constructors">Ord</span><span>&nbsp;a)</span><span class="syntax_operators">&nbsp;=&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span>a</span><span class="syntax_operators">&nbsp;-&gt;&nbsp;</span><span class="type_constructors">Ordering</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>a&nbsp;<span class="common_operators">`myCompare`</span><span>&nbsp;b&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>a</span><span class="common_operators">&nbsp;&gt;&nbsp;</span><span>b&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="type_constructors">GT</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>a</span><span class="common_operators">&nbsp;==&nbsp;</span><span>b&nbsp;&nbsp;&nbsp;</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="type_constructors">EQ</span><span>&nbsp;&nbsp;</span></span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;<span class="common_operators">&nbsp;|&nbsp;</span><span>otherwise</span><span class="common_operators">&nbsp;=&nbsp;</span><span class="type_constructors">LT</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">myCompare :: (Ord a) =&gt; a -&gt; a -&gt; Ordering
a `myCompare` b
    | a &gt; b     = GT
    | a == b    = EQ
    | otherwise = LT
</pre>
<div class="dp-highlighter nogutter"><div class="bar"></div><ol class="dp-hs" start="1"><li class="alt"><span><span class="ghci">ghci&gt;</span><span>&nbsp;</span><span class="numbers">3</span><span>&nbsp;</span><span class="common_operators">`myCompare`</span><span>&nbsp;</span><span class="numbers">2</span><span>&nbsp;&nbsp;</span></span></li><li class=""><span><span class="type_constructors">GT</span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="haskell:hs" style="display: none;">ghci&gt; 3 `myCompare` 2
GT
</pre>
<div class="hintbox"><em>Note:</em> Not only can we call functions as infix with backticks, we can also define them using backticks. Sometimes it's easier to read that way.</div>